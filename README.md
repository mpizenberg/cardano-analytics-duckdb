# Cardano Analytics

The goal of this project is to make analytics on Cardano easier, more efficient, and more accessible to the community.
To that aim, we are defining a standard format based on Parquet files, and accessible with DuckDB.
Parquet files will be organized in folders, where each folder matches a range of 200000 slots (roughly 55 hours), for example `slot_15000000_15199999/`.
Inside each folder, we will have the following files:
- `tx-raw.parquet` containing raw transaction data
- `tx.parquet` containing basic information about transactions
- `utxo.parquet` containing basic information about UTxOs
- `asset.parquet` containing basic information about native assets in transactions
- `mint.parquet` containing basic information about minting in transactions
- `cert.parquet` containing basic information about certificates in transactions
- `vote.parquet` containing basic information about votes in transactions
- `proposal.parquet` containing basic information about proposals in transactions
- `redeemer.parquet` containing basic information about redeemers in transactions

## Parquet Schemas

Here are the detailed types needed for each of the aforementioned parquet files.
TODO: add tx_id to tx-raw.parquet?
TODO: add slot to all parquet files?

- `tx-raw.parquet`:
  - `raw_cbor`: BYTE_ARRAY

- `tx.parquet`:
  - `tx_id`: FIXED_LEN_BYTE_ARRAY(32)
  - `block_height`: INT32
  - `slot`: INT64
  - `tx_fee`: INT64
  - `ref_input_count`: INT32
  - `input_count`: INT32
  - `output_count`: INT32
  - `redeemer_count`: INT32
  - `has_mint`: BOOLEAN
  - `has_withdrawal`: BOOLEAN
  - `has_cert`: BOOLEAN
  - `has_vote`: BOOLEAN
  - `has_proposal`: BOOLEAN

- `utxo.parquet`:
  - `tx_id`: FIXED_LEN_BYTE_ARRAY(32)
  - `output_index`: INT32
  - `address`: ASCII STRING
  - `lovelace`: INT64
  - `is_script_address`: BOOLEAN
  - `has_token`: BOOLEAN
  - `has_datum`: BOOLEAN
  - `has_ref_script`: BOOLEAN

- `asset.parquet`:
  - `tx_id`: FIXED_LEN_BYTE_ARRAY(32)
  - `output_index`: INT32
  - `policy_id`: FIXED_LEN_BYTE_ARRAY(28)
  - `asset_name`: BYTE_ARRAY
  - `quantity`: INT64

Remark that if we also store the address in the asset table in addition to the utxo table, it increases the asset parquet files by 30% approximately.
And overall, without raw tx, it’s a 2% size increase.
So the question to duplicate or not the address info into the asset table depends if we always want to know the address or not.

- `mint.parquet`:
  - `tx_id`: FIXED_LEN_BYTE_ARRAY(32)
  - `policy_id`: FIXED_LEN_BYTE_ARRAY(28)
  - `asset_name`: BYTE_ARRAY
  - `quantity`: INT64

- `cert.parquet`:
  - `tx_id`: FIXED_LEN_BYTE_ARRAY(32)
  - `index`: INT32
  - `type`: ASCII STRING  TODO: change to INT32

- `vote.parquet`:
  - `tx_id`: FIXED_LEN_BYTE_ARRAY(32)
  - `voter`: ASCII STRING
  - `action_id_tx`: FIXED_LEN_BYTE_ARRAY(32)
  - `action_id_index`: INT32
  - `vote`: INT32
  - `anchor`: ASCII STRING

- `proposal.parquet`:
  - `tx_id`: FIXED_LEN_BYTE_ARRAY(32)
  - `proposal_index`: INT32
  - `deposit`: INT64
  - `return_account`: ASCII STRING
  - `type`: INT32
  - `anchor`: ASCII STRING

- `redeemer.parquet`:
  - `tx_id`: FIXED_LEN_BYTE_ARRAY(32)
  - `tag`: INT32
  - `redeemer_index`: INT32
  - `data`: BYTE_ARRAY
  - `mem`: INT64
  - `steps`: INT64

## Generation of the Parquet Files

Eventually, an efficient method to generate these files will be needed.
Currently, we are working on a small subset of the history, so we are using Ogmios to generate the data.

## Case Study: SNEK Tx fees

Let’s try to build the data and requests needed to find how much network fees are generated by the SNEK project.
This implies finding fees where the SNEK token is involved, as well as the other protocols handled by the SNEK project such as the `snek.fun` platform.

- SNEK policy ID: `279c909f348e533da5808898f87f9a14bb2c3dfbbacccd631d927a3f`
- SNEK asset name: `534e454b`
- Splash order contract for snek.fun (same): `464eeee89f05aff787d40045af2a40a83fd96c513197d32fbc54ff02`
- Splash pool contract for snek.fun will depend on pool asset, for example with crawju/ada: `cb684a69e78907a9796b21fc150a758af5f2805e5ed5d5a8ce9f76f1`

I’d be curious to know if there is a more reliable way to identify snek fun transactions.
Because manually adding pools, and filtering orders based on the datum or assets will not be scalable.

## Community Interest

Trying to gather some ideas/whishes:

- `@KylixAfonso`: retrieving history of a state-thread token (sst) utxo and its datum
- `@SteelSwap`: portfolio can get tricky if you want to track it historically
- `@alxaex`: daily progression of the utxo set. Also of network fees as a proxy to network activity.
- `@adatainment`:
  - proposed and enacted parameter updates
  - rewards history per epoch
  - redelegation per epoch
  - any pool parameter updates
- `@NicolasC3rny`: governance KPIs https://docs.google.com/document/d/1NQWMkOPWOgLoBr8FY3OLFEjuupyt-9h-xvWcA6xaP7E/edit?tab=t.0
- `@_KtorZ_`:
  - smart contract usage (per language, per script, ...)
  - plutus builtin usage
- `@jonahkoch`: tracking of defi kernel beacon tokens
- `@SmaugPool`:
  - pool stake at a specific slot
  - DRep stake at a specific slot
  - votes yes/no/abstain stake at a specific slot.
  - stake address value at a specific slot (at least lovelaces with rewards; native assets could be useful too)
- `@CardanoDiplomat`: address balance
- `@solidsnakedev`: integrations with Firehose + Substreams (nowitness labs)
